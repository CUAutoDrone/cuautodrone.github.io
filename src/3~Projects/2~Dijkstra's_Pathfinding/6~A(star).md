# A* and extensions of Dijkstra's
A* (pronounced A-star) is an algorithm similar to Dijkstra's that is much faster in practice and still provides optimal results. It does this by leveraging additional information available in most real-world pathfinding applications. This extra info is a guess for how close somewhere is to the goal. The effect is that A* will behave much closer to how a person might find their way to the grocery store. You walk in the direction of the store until you hit an obstacle, then you try to go around the obstacle.

At first, this might seem completely different from how Dijkstra's works. Dijkstra's essentially finds all the places you can get in 1 step and then finds all the places you can get in 2 steps... until it reaches the goal. But A* and Dijkstra's are actually the same algorithm at their core. The way that A* works is that it weighs places more that it thinks are closer to the goal. Basically, A* will find all the places that you can get to in 1 step and are 10 steps from the goal or 2 steps and 9 steps from the goal before going on to the next section (2 steps from the start, 10 steps from the goal, and 3 steps and 9 steps). By also considering how far they are from the goal, it can be much more efficient in its search (often orders of magnitude). To implement A* just change a new node's priority from $\text{dist\_from\_source}$ to $\text{dist\_from\_source} + \text{dist\_to\_end}$ and implement $\text{dist\_to\_end}$ as [euclidean](https://en.wikipedia.org/wiki/Euclidean_distance) or [manhattan](https://xlinux.nist.gov/dads/HTML/manhattanDistance.html) distance.

Here's an example from [Andrew Myers' 2110 textbook](https://andrewcmyers.github.io/oodds/lecture.html?id=ssp), if you were trying to find a path from NYC to Mt. Rushmore, Dijkstra's would explore streets in Miami, even though that's clearly unnecessary.

![An example of the potential inefficiencies of Dijkstra's, from 2110 textbook](imgs/a-star/map.png)

You might be wondering, "How can I know how far I am from the goal if I don't know the path to the goal?" and that's a good question. Turns out we don't need to know the exact distance, we just need an approximation. A common approximation is just the distance to the goal if there were no obstacles. The approximation we used is called the heuristic. It turns out that if we want the heuristic to work (this is what is called an "admissible" heuristic), it can never overestimate the amount of distance left. A* works better than Dijkstra's because it considers both how far the point is from the goal (roughly) as well as how far we've traveled, so the amount of explored nodes decreases significantly. There is actually no guarantee that A* is faster than Dijkstra's but in practice, it is almost always significantly faster.

A* is still widely used in practice and beyond A*, there are a huge number of path-finding algorithms. Many of them use A* (and thus Dijkstra's) as a foundation, examples include [Theta*](http://www.gameaipro.com/GameAIPro2/GameAIPro2_Chapter16_Theta_Star_for_Any-Angle_Pathfinding.pdf), an any-angle pathfinding algorithm (and it's variant [Lazy Theta*](http://idm-lab.org/bib/abstracts/papers/aaai10b.pdf)) and [Jump Point Search](https://zerowidth.com/2013/a-visual-explanation-of-jump-point-search.html).